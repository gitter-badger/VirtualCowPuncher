#!/usr/bin/env node

/**
 * Module dependencies.
 */


var app = require('./app');
var debug = require('debug')('CowPuncher:server');
//var http = require('http');
var https = require('https');
var fs = require('fs');

/**
 * Get port from environment and store in Express.
 */

var port = normalizePort(process.env.PORT || '3000');
app.set('port', port);

/**
 * Create HTTP server.
 */

var options =  { 
	key:    fs.readFileSync('certs/cowpuncher.key'),
   cert:   fs.readFileSync('certs/cowpuncher.cert'),
   ca:     fs.readFileSync('certs/cowpuncher.cert')
};


var server = https.createServer(options, app);

var squareSize = 20;
var boardSize = 600;
var squaresAcross = boardSize / squareSize;

function randomCoordinate() {
	return Math.floor((Math.random() * squaresAcross));
}

var number_of_cows = 20;
var cows = [];

var too_close = 5;

for (var q = 0; q < number_of_cows; q++) {
	cows.push([randomCoordinate(), randomCoordinate()]);
}

var io = require('socket.io').listen(server);

var locations = {};

io.on('connection', function (socket) {
	console.log('a user connected');
	var clientID;

	socket.on('disconnect', function () {
		console.log('user disconnected');
		delete locations[clientID];
	});

	socket.on('click', function (socket) {
		console.log("clicked");
		io.emit('clicked', "sdgasfd");
	});

	socket.on('move', function (movement) {
		console.log(movement);
		clientID = movement['id'];
		locations[movement['id']] = {'x': movement['x'], 'y': movement['y']};
		io.emit('locations', locations);

		for(var cow in cows){
			var this_cow = cows[cow];
			var x = movement['x'];
			var y = movement['y'];
			var diff_x = Math.abs(this_cow[0] - x);
			var diff_y = Math.abs(this_cow[1] - y);
			var diff = diff_x + diff_y;
			if(diff < too_close){
				if(diff_x > diff_y){
					if(this_cow[0] > x){
						this_cow[0] = this_cow[0] + 1;
					}else{
						this_cow[0] = this_cow[0] - 1;
					}
				}else{
					if(this_cow[1] > y){
						this_cow[1] = this_cow[1] + 1;
					}else{
						this_cow[1] = this_cow[1] - 1;
					}
				}
			}
		}

		io.emit('cow_locations', cows);
	});

});


/**
 * Listen on provided port, on all network interfaces.
 */

server.listen(port);
server.on('error', onError);
server.on('listening', onListening);

/**
 * Normalize a port into a number, string, or false.
 */

function normalizePort(val) {
	var port = parseInt(val, 10);

	if (isNaN(port)) {
		// named pipe
		return val;
	}

	if (port >= 0) {
		// port number
		return port;
	}

	return false;
}

/**
 * Event listener for HTTP server "error" event.
 */

function onError(error) {
	if (error.syscall !== 'listen') {
		throw error;
	}

	var bind = typeof port === 'string'
		? 'Pipe ' + port
		: 'Port ' + port;

	// handle specific listen errors with friendly messages
	switch (error.code) {
		case 'EACCES':
			console.error(bind + ' requires elevated privileges');
			process.exit(1);
			break;
		case 'EADDRINUSE':
			console.error(bind + ' is already in use');
			process.exit(1);
			break;
		default:
			throw error;
	}
}

/**
 * Event listener for HTTP server "listening" event.
 */

function onListening() {
  var addr = server.address();
  var bind = typeof addr === 'string'
    ? 'pipe ' + addr
    : 'port ' + addr.port;
  console.log('Listening Https on ' + bind);
  debug('Listening Https on ' + bind);
}

